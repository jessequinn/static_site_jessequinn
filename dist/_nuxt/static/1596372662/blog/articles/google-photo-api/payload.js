__NUXT_JSONP__("/blog/articles/google-photo-api", (function(a,b,c,d,e,f,g,h,i,j,k,l,m){return {data:[{article:{title:m,description:"Google Photos API how-to",img:"joao-tzanno-G9_Euqxpu4k-unsplash.jpg",alt:m,featured:0,author:{name:"Jesse Quinn",bio:"All about Jesse",img:"https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1533636721434-0e2d61030955?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2550&q=80",alt:"profile photo"},publishedAt:"2019-10-28T03:00:00.000Z",updateAt:g,toc:[],body:{type:"root",children:[{type:b,tag:e,props:{},children:[{type:a,value:"Well what a learning process that was.... I am referring to my time spent working with the "},{type:b,tag:"a",props:{href:"https:\u002F\u002Fdevelopers.google.com\u002Fphotos\u002Flibrary\u002Fguides\u002Foverview",rel:["nofollow","noopener","noreferrer"],target:"_blank"},children:[{type:a,value:"Google API"}]},{type:a,value:" for Google Photos. In my opinion it is just a mess. Long story short, I wanted a way to store images and Heroku was not an option. Of couse you can use S3 or some other paid service or may be even imgur. However, I like Google Photos, but in retrospect, may be I should have used some other service."}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"As previously stated, I wanted a way to store images and recall them for basic public use. Following along with the API documentation, specifically for PHP, I simply wanted to upload media. Well that being said, it was not so easy. Using some code from the samples, I was eventually able to connect to the Google API. Let's look at that code."}]},{type:a,value:d},{type:b,tag:h,props:{className:[i]},children:[{type:b,tag:j,props:{className:[k,l]},children:[{type:b,tag:c,props:{},children:[{type:a,value:"use Google\\Auth\\Credentials\\UserRefreshCredentials;\nuse Google\\Auth\\OAuth2;\nuse Google\\Photos\\Library\\V1\\PhotosLibraryClient;\nuse Google\\Photos\\Library\\V1\\PhotosLibraryResourceFactory;\nuse Google\\Rpc\\Code;\n\npublic function ... {\n    $clientSecretJson = json_decode(\n            file_get_contents(__DIR__ . '\u002F..\u002F..\u002Fclient_secret.json'),\n            true\n    )['web'];\n\n    $clientId = $clientSecretJson['client_id'];\n    $clientSecret = $clientSecretJson['client_secret'];\n    $redirectURI = 'https:\u002F\u002Fsomesite\u002Fauth\u002Fgoogle\u002Fcallback';\n    $scopes = [\n            'https:\u002F\u002Fwww.googleapis.com\u002Fauth\u002Fphotoslibrary',\n            'https:\u002F\u002Fwww.googleapis.com\u002Fauth\u002Fphotoslibrary.sharing'\n    ];\n\n    $oauth2 = new OAuth2([\n            'clientId' =\u003E $clientId,\n            'clientSecret' =\u003E $clientSecret,\n            'authorizationUri' =\u003E 'https:\u002F\u002Faccounts.google.com\u002Fo\u002Foauth2\u002Fv2\u002Fauth',\n            \u002F\u002F Where to return the user to if they accept your request to access their account.\n            \u002F\u002F You must authorize this URI in the Google API Console.\n            'redirectUri' =\u003E $redirectURI,\n            'tokenCredentialUri' =\u003E 'https:\u002F\u002Fwww.googleapis.com\u002Foauth2\u002Fv4\u002Ftoken',\n            'scope' =\u003E $scopes,\n    ]);\n    \n    ... more code here ...\n    \n}\n"}]}]}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"So what we are doing here is accessing the "},{type:b,tag:c,props:{},children:[{type:a,value:"client_secret.json"}]},{type:a,value:" file that is\\was downloaded from the Google API credentials area. From this file I pull out the "},{type:b,tag:c,props:{},children:[{type:a,value:"client_id"}]},{type:a,value:" and "},{type:b,tag:c,props:{},children:[{type:a,value:"client_secret"}]},{type:a,value:" that I will pass to OAuth. I recommend putting this within the function\u002Froute that will make direct call to the API for access as a redirect is required that will send a "},{type:b,tag:c,props:{},children:[{type:a,value:c}]},{type:a,value:" back to the same route. This route you need to add to the API credentials in the web application you created on the Google API site. It may even be advisable to use environmental variables rather than pulling information from a json file."}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"Next we need to capture the "},{type:b,tag:c,props:{},children:[{type:a,value:c}]},{type:a,value:" that is sent back to you and your route, verify, and store credentials. "}]},{type:a,value:d},{type:b,tag:h,props:{className:[i]},children:[{type:b,tag:j,props:{className:[k,l]},children:[{type:b,tag:c,props:{},children:[{type:a,value:"$code = $request-\u003EgetQueryParam('code', $default = null);\n\n\u002F\u002F The authorization URI will, upon redirecting, return a parameter called code.\nif ($code === null) {\n        $authenticationUrl = $oauth2-\u003EbuildFullAuthorizationUri(['access_type' =\u003E 'offline']);\n        return $response-\u003EwithHeader('Location', $authenticationUrl);\n\n} else {\n        \u002F\u002F With the code returned by the OAuth flow, we can retrieve the refresh token.\n        $oauth2-\u003EsetCode($code);\n        $authToken = $oauth2-\u003EfetchAuthToken();\n        $refreshToken = $authToken['access_token'];\n        \u002F\u002F The UserRefreshCredentials will use the refresh token to 'refresh' the credentials when\n        \u002F\u002F they expire.\n        $session-\u003Eset('credentials', new UserRefreshCredentials(\n                $scopes,\n                [\n                        'client_id' =\u003E $clientId,\n                        'client_secret' =\u003E $clientSecret,\n                        'refresh_token' =\u003E $refreshToken\n                ]\n        ));\n\n        return $response-\u003EwithRedirect($this-\u003Erouter-\u003EpathFor('somesiteurl'));\n"}]}]}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"If no "},{type:b,tag:c,props:{},children:[{type:a,value:c}]},{type:a,value:" exists you will be sent to the authentication URL to sign in. Once signed in, the route you setup previous, "},{type:b,tag:c,props:{},children:[{type:a,value:"$redirectURI"}]},{type:a,value:", should return with a "},{type:b,tag:c,props:{},children:[{type:a,value:"?code=someverylongalphanumericvalue"}]},{type:a,value:" appended. Once we have that "},{type:b,tag:c,props:{},children:[{type:a,value:c}]},{type:a,value:" we can pass the "},{type:b,tag:c,props:{},children:[{type:a,value:"setCode()"}]},{type:a,value:" function the "},{type:b,tag:c,props:{},children:[{type:a,value:c}]},{type:a,value:" that will be use to provide the refresh token value that we store with the client id and client secret in a session. I use a special class for storing session data so it should look different for you."}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"So now we have setup the code for loggin into the Google API, I wanted to upload an image."}]},{type:a,value:d},{type:b,tag:h,props:{className:[i]},children:[{type:b,tag:j,props:{className:[k,l]},children:[{type:b,tag:c,props:{},children:[{type:a,value:"$photosLibraryClient = new PhotosLibraryClient(['credentials' =\u003E $session-\u003Ecredentials]);\n\n$uploadToken = $photosLibraryClient-\u003Eupload(\n        file_get_contents($uploadedFile-\u003Efile),\n        $filename\n);\n\n$listAlbumsResponse = $photosLibraryClient-\u003ElistAlbums();\n\nforeach ($listAlbumsResponse-\u003EiterateAllElements() as $album) {\n        if ($album-\u003EgetTitle() === 'somealbumname') {\n                $albumId = $album-\u003EgetId();\n                $albumExists = true;\n                break;\n        }\n}\n\nif (!$albumExists) {\n        $newAlbum = PhotosLibraryResourceFactory::album('somealbumname');\n        $createdAlbumResponse = $photosLibraryClient-\u003EcreateAlbum($newAlbum);\n        $albumId = $createdAlbumResponse-\u003EgetId();\n}\n\n$itemDescription = 'new post photo ' . $filename;\n$newMediaItems[] = PhotosLibraryResourceFactory::newMediaItemWithDescription($uploadToken, $itemDescription);\n$batchCreateResponse = $photosLibraryClient-\u003EbatchCreateMediaItems($newMediaItems, [\n        'albumId' =\u003E $albumId\n]);\n\nforeach ($batchCreateResponse-\u003EgetNewMediaItemResults() as $itemResult) {\n        $status = $itemResult-\u003EgetStatus();\n        if ($status-\u003EgetCode() != Code::OK) {\n                $this-\u003Eflash-\u003EaddMessage('error', 'Error with photo item being created.');\n                return $response-\u003EwithRedirect($this-\u003Erouter-\u003EpathFor('admin-edit-post-form',\n                        [\n                                'id' =\u003E $post_data['post_id'],\n                        ]));\n        } else {\n                $mediaItem = $itemResult-\u003EgetMediaItem();\n                $id = $mediaItem-\u003EgetId();\n                $item = $photosLibraryClient-\u003EgetMediaItem($id);\n                $baseUrl = $item-\u003EgetBaseUrl();\n                $filename = $baseUrl;\n        }\n}\n"}]}]}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"So we have a long piece of code here. We begin by making a new instance of "},{type:b,tag:c,props:{},children:[{type:a,value:"PhotosLibraryClient"}]},{type:a,value:" and pass the constructor with the session credentials. Next we need to make an upload token that contains the file contents and filename as parameters. Because, from my experience, we cannot work with albums that already exist, we need to first create one. Once created, we can continuously use it. Odd? I thought so. Apparently, unless i am using the wrong scope, we cannot access an already created album that is shared. Nonetheless, we can validate each time if the album exists or not. If it does not create it. Next, we make a new media item by passing the upload token and item description to the "},{type:b,tag:c,props:{},children:[{type:a,value:"newMediaItemWithDescription()"}]},{type:a,value:" function and then call the "},{type:b,tag:c,props:{},children:[{type:a,value:"batchCreateMediaItems()"}]},{type:a,value:" with the item and the "},{type:b,tag:c,props:{},children:[{type:a,value:"albumId"}]},{type:a,value:". Done, you should have uploaded the new media item. We can subsequently validate the item with the "},{type:b,tag:c,props:{},children:[{type:a,value:"getNewMediaItemResults()"}]},{type:a,value:" in a foreach. I am assuming we would upload many photos. I believe up to 50 at one time are allowed. If the item is ok, I want to access the "},{type:b,tag:c,props:{},children:[{type:a,value:f}]},{type:a,value:" for public usage. This is another quark, I thought that I would be able to use the "},{type:b,tag:c,props:{},children:[{type:a,value:"itemResult"}]},{type:a,value:" as it does have a "},{type:b,tag:c,props:{},children:[{type:a,value:f}]},{type:a,value:", but it is empty. Therefore, i need to call the "},{type:b,tag:c,props:{},children:[{type:a,value:"getMediaItem()"}]},{type:a,value:" with the id of the newly created item to obtain the "},{type:b,tag:c,props:{},children:[{type:a,value:f}]},{type:a,value:". You can store the "},{type:b,tag:c,props:{},children:[{type:a,value:f}]},{type:a,value:" in a file or database to dynamically add to your site for a source to your images."}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"The end."}]}]},dir:"\u002Farticles",path:"\u002Farticles\u002Fgoogle-photo-api",extension:".md",slug:"google-photo-api",createdAt:"2020-07-22T00:27:09.709Z",updatedAt:"2020-07-22T00:30:14.102Z"},prev:{title:"ACS Override Patched Manjaro Kernel Walk-through",updateAt:g,slug:"acs-override"},next:{title:"GPU Pass-through Manjaro Walk-through",updateAt:g,slug:"gpu-passthrough"}}],fetch:[],mutations:[]}}("text","element","code","\n","p","baseUrl","2020-07-19T03:00:00.000Z","div","nuxt-content-highlight","pre","language-text","line-numbers","Google Photos API and Photo Storage")));